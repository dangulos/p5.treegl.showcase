[{"id":0,"href":"/showcase/docs/Componentes/Arrow/","title":"Arrow","section":"Componentes","content":" Arrow # Es una simple flecha hecha utilizando pipe\u0026rsquo;s. Resulta √∫til para se√±alar puntos dada la necesidad.\nPar√°metros # detail number : El detalle de la flecha. Entre mayor sea, m√°s suave se ve. radius number : Radio de la flecha. height number : Altura de la flecha. Showcase # code # sketch.js // gui params var detail = 16; var radius = 20; var height = 20; var gui; function setup() { createCanvas(450, 450, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); gui = createGui(\u0026#39;Axes\u0026#39;); gui.addGlobals(\u0026#39;detail\u0026#39;, \u0026#39;radius\u0026#39;, \u0026#39;height\u0026#39;); } function draw() { rotateX(-0.5); rotateY(-0.5); background(255); stroke(0); strokeWeight(1); fill(0, 0, 255); push(); arrow({detail, radius, height}); pop(); } "},{"id":1,"href":"/showcase/docs/Componentes/Axes/","title":"Axes","section":"Componentes","content":" Axes # Los Axes (o ejes en espa√±ol) dibujan tres l√≠neas ortogonales en 3D que pueden ser √∫tiles como punto de referencia al momento de rotar alg√∫n objeto\nPar√°metros # size number : Tama√±o de los ejes, todos los ejes comparten la misma distancia. bits number : Bitmask que permite indicar qu√© ejes dibujar. Uso de la Bitmask # El par√°metro bits permite elegir qu√© ejes se dibujan y a pesar de que el par√°metro que se ingresa es un n√∫mero, funciona como una Bitmask (Similar a los permisos num√©ricos del comando chmod en GNU/Linux). La bitmask permite que se puedan elegir distintas opciones en un s√≥lo par√°metro. La librer√≠a a√±ade el objeto Tree que permite un acceso sencillo a los bits necesarios para marcar opciones. La distribuci√≥n de las selecciones posibles se encuentra ordenada de la siguiente manera:\nDescription Valor en Tree Binario Decimal Dibuja el eje X Tree.X 0000001 1 Dibuja el eje Y Tree.Y 0000010 2 Dibuja el eje Z Tree.Z 0000100 4 Dibuja el eje -X Tree._X 0001000 8 Dibuja el eje -Y Tree._Y 0010000 16 Dibuja el eje -z Tree._Z 0100000 32 Dibuja labels que indican el eje Tree.LABELS 1000000 64 Ejemplos # Si se quisiera mostrar todos los ejes positivos sin los label se podr√≠a hacer de la siguiente manera:\naxes({ size: 100, bits: Tree.X | Tree.Y | Tree.Z }); Como sabemos que bits es un numero, puede recibir directamente un valor n√∫merico que, aunque un poco m√°s confuso, dar√≠a un c√≥digo m√°s corto. Simplemente se toman los valores de la tabla de arriba y se suman. Esto corresponder√≠a a 1 + 2 + 4 = 7. Por ejemplo, el siguiente c√≥digo es equivalente al de arriba:\naxes({ size: 100, bits: 7 }); Showcase # code # sketch.js var easycam; var size = 100; var X = true; var Y = true; var Z = true; var _X = false; var _Y = false; var _Z = false; var LABELS = false; var gui; function setup() { createCanvas(400, 400, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); gui = createGui(\u0026#39;Axes\u0026#39;); gui.addGlobals(\u0026#39;size\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Z\u0026#39;, \u0026#39;_X\u0026#39;, \u0026#39;_Y\u0026#39;, \u0026#39;_Z\u0026#39;, \u0026#39;LABELS\u0026#39;); } function draw() { rotateX(-0.5); rotateY(-0.5); background(255); push(); axes({ size: size, bits: parseSelection() }); pop(); } function parseSelection() { let result = 0; if (X) result = result | Tree.X; if (Y) result = result | Tree.Y; if (Z) result = result | Tree.Z; if (_X) result = result | Tree._X; if (_Y) result = result | Tree._Y; if (_Z) result = result | Tree._Z; if (LABELS) result = result | Tree.LABELS; return result; } "},{"id":2,"href":"/showcase/docs/Componentes/Bagel/","title":"Bagel","section":"Componentes","content":" Bagel # El bagel o \u0026ldquo;figure 8\u0026rdquo; es una immersi√≥n de la botella de Klein. Esta figura se puede hacer uniendo dos cintas de M√∂bius.\nPar√°metros # mayorDetail number : Detalle del recorrido del radio mayor del bagel minorDetail number : Detalle del recorrido del radio menor del bagel. mayorRadius number : Radio desde el centro del bagle hasta el centro de su \u0026ldquo;cuerpo\u0026rdquo;. minorDetail number : Radio desde el centro del \u0026ldquo;cuerpo\u0026rdquo; hasta la superficie externa de este. Showcase # code # sketch.js // gui params var mayorRadius = 16; var minorRadius = 20; var mayorDetail = 16; var minorDetail = 16; var gui; function setup() { createCanvas(450, 450, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); gui = createGui(\u0026#39;Axes\u0026#39;); gui.addGlobals(\u0026#39;mayorRadius\u0026#39;, \u0026#39;minorRadius\u0026#39;, \u0026#39;mayorDetail\u0026#39;, \u0026#39;minorDetail\u0026#39;); } function draw() { rotateX(-0.5); rotateY(-0.5); background(255); stroke(0); strokeWeight(1); fill(0, 0, 255); push(); bagel({mayorRadius, minorRadius, mayorDetail, minorDetail}); pop(); } "},{"id":3,"href":"/showcase/docs/Componentes/Bullseye/","title":"Bullseye","section":"Componentes","content":" Bullseye # Los bullseye son figuras en 2D que facilitan indentificar la posici√≥n de un objeto en 3D.\nPar√°metros # x number : Posici√≥n en x. y number : Posici√≥n en y. size number : Di√°metro del bullseye. shape number : El bullseye puede mostrarse en forma circular (con Tree.CIRCLE) o cuadrada (con Tree.SQUARE). Defacto es circular. Showcase # code # sketch.js // gui params var x = 200; var y = 200; var size = 150; var shape = [\u0026#39;Tree.CIRCLE\u0026#39;, \u0026#39;Tree.SQUARE\u0026#39;]; var selectedShape; var gui; function setup() { createCanvas(400, 400, WEBGL); gui = createGui(\u0026#39;Bullseye\u0026#39;); gui.addGlobals(\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;size\u0026#39;, \u0026#39;shape\u0026#39;); noLoop(); } function draw() { // pick a shape switch (shape) { case \u0026#39;Tree.SQUARE\u0026#39;: selectedShape = Tree.SQUARE; break; default: selectedShape = Tree.CIRCLE; break; } background(255); stroke(0, 255, 255); strokeWeight(4); push(); bullsEye({ x, y, size, shape: selectedShape }); pop(); } "},{"id":4,"href":"/showcase/docs/Componentes/Grid/","title":"Grid","section":"Componentes","content":" Grid # Una grid es una cuadr√≠cula que facilita visualizar el tama√±o, movimiento o rotaci√≥n de un objeto al colocarla desde un punto relativo.\nPar√°metros # subdivisions number : Cantidad de subdivisiones. size number : Tama√±o de la cuadrilla. shape number : La cuadrilla puede mostrarse en forma punteada (con Tree.DOTS) o s√≥lida (con Tree.SOLID). Defacto es punteada. Showcase # code # sketch.js // gui params var subdivisions = 10; var size = 200; var style = [\u0026#39;Tree.DOTS\u0026#39;, \u0026#39;Tree.SOLID\u0026#39;]; var selectedstyle; var gui; function setup() { createCanvas(400, 400, WEBGL); gui = createGui(\u0026#39;Grid\u0026#39;); gui.addGlobals(\u0026#39;subdivisions\u0026#39;, \u0026#39;size\u0026#39;, \u0026#39;style\u0026#39;); noLoop(); } function draw() { // pick a style switch (style) { case \u0026#39;Tree.SOLID\u0026#39;: selectedStyle = Tree.SOLID; break; default: selectedStyle = Tree.DOTS; break; } background(255); stroke(0); strokeWeight(4); push(); grid({ subdivisions, size, style: selectedStyle }); pop(); } "},{"id":5,"href":"/showcase/docs/Componentes/Mobius_Strip/","title":"Mobius Strip","section":"Componentes","content":" M√∂bius Strip # Una cinta de M√∂bius es una cinta continua que tiene una sola superficie.\nPar√°metros # detail number : El detalle de la cinta. Entre mayor sea, m√°s suave se ve. radius number : Radio de la cinta. Showcase # code # sketch.js // gui params var detail = 16; var radius = 20; var gui; function setup() { createCanvas(450, 450, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); gui = createGui(\u0026#39;Axes\u0026#39;); gui.addGlobals(\u0026#39;detail\u0026#39;, \u0026#39;radius\u0026#39;); } function draw() { rotateX(-0.5); rotateY(-0.5); background(255); stroke(0); strokeWeight(1); fill(0, 0, 255); push(); mobius({detail, radius}); pop(); } "},{"id":6,"href":"/showcase/docs/Componentes/Pipe/","title":"Pipe","section":"Componentes","content":" Pipe # Un pipe es un cilindro cuyas bases se pueden rotar dado un vector espec√≠fico. Esta figura es √∫til porque cuando se concatenan varias se pueden hacer figuras m√°s completas.\nPar√°metros # detail number : El detalle del cilindro. Entre mayor sea, m√°s suave se ve. topRadius number : Radio de la base superior del cilindro. bottomRadius number : Radio de la base inferior del cilindro. height number : La altura del cilindro. topNormal p5.Vector : Vector que indica c√≥mo est√° inclinada la base superior del cilindro. bottomNormal p5.Vector : Vector que indica c√≥mo est√° inclinada la base inferior del cilindro. Showcase # code # sketch.js // gui params var detail = 16; var topRadius = 20; var bottomRadius = 20; var cylinderHeight = 250; var topNormalX = 100; var topNormalY = 100; var bottomNormalX = 100; var bottomNormalY = 100; var gui; function setup() { createCanvas(450, 450, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); gui = createGui(\u0026#39;Axes\u0026#39;); gui.addGlobals(\u0026#39;detail\u0026#39;, \u0026#39;topRadius\u0026#39;, \u0026#39;bottomRadius\u0026#39;, \u0026#39;cylinderHeight\u0026#39;, \u0026#39;topNormalX\u0026#39;, \u0026#39;topNormalY\u0026#39;, \u0026#39;bottomNormalX\u0026#39;, \u0026#39;bottomNormalY\u0026#39;); } function draw() { rotateX(-0.5); rotateY(-0.5); background(255); stroke(0); strokeWeight(1); fill(0, 0, 255); let topVector = { x: map(topNormalX, 0, 100, -1, 1), y: map(topNormalY, 0, 100, -1, 1), }; let bottomVector = { x: map(bottomNormalX, 0, 100, -1, 1), y: map(bottomNormalY, 0, 100, -1, 1), }; push(); pipe({ detail, topRadius, bottomRadius, height: cylinderHeight, topNormal: new p5.Vector(topVector.x, topVector.y, 1), bottomNormal: new p5.Vector(bottomVector.x, bottomVector.y, -1), }); pop(); } "},{"id":7,"href":"/showcase/docs/Componentes/viewFrustum/","title":"View Frustum","section":"Componentes","content":" ViewFrustum # Treegl permite visualizar el volumen que est√° renderizando una c√°mara por medio de un frustum. √âste frustum mustra la posici√≥n de la pantalla, la distancia de renderizado y la forma que esta toma.\nPar√°metros # fbo p5.RendererGL | p5.Graphics : Es el renderer que va a mostrar el frustum. bits number : Bitmask para controlar diversos par√°metros como qu√© pl√°nos se dibujan. viewer function : Callback para mostrar la representaci√≥n visual del fbo. Uso de la Bitmask # El par√°metro bits permite elegir qu√© ejes se dibujan y a pesar de que el par√°metro que se ingresa es un n√∫mero, funciona como una Bitmask (Similar a los permisos num√©ricos del comando chmod en GNU/Linux). La bitmask permite que se puedan elegir distintas opciones en un s√≥lo par√°metro. La librer√≠a a√±ade el objeto Tree que permite un acceso sencillo a los bits necesarios para marcar opciones. La distribuci√≥n de las selecciones posibles se encuentra ordenada de la siguiente manera:\nDescription Valor en Tree Binario Decimal Dibuja el plano lejano Tree.NEAR 0000001 1 Dibuja el plano cercano Tree.FAR 0000010 2 Dibuja el l√≠mite izquierdo Tree.LEFT 0000100 4 Dibuja el l√≠mite derecho Tree.RIGHT 0001000 8 Dibuja el l√≠mite inferior Tree.BOTTOM 0010000 16 Dibuja el l√≠mite superior Tree.TOP 0100000 32 Dibuja el cuerpo del frostum Tree.BODY 1000000 64 Proyecci√≥n ortogr√°fica # En la proyecci√≥n ortogr√°fica, la c√°mara que est√° renderizando la escena no identifica profundidad. Esto implica que independientemente de qu√© tan lejos se encuentra un objeto de la c√°mara, √©ste conservar√° su tama√±o.\ncode # sketch.js \u0026#39;use strict\u0026#39;; let fbo1, fbo2; let cam1, cam2; let height = 600; let boxes; let persp = true; var left = 300; var right = 300; var frustum_width = 600; var bottom = 300; var topa = 300; var frustum_height = 600; var far = 500; var gui; function setup() { createCanvas(300, 600); fbo1 = createGraphics(width, height/2, WEBGL); fbo2 = createGraphics(width, height/2, WEBGL); fbo1.ortho(-fbo1.width / 2, fbo1.width / 2, -fbo1.height / 2, fbo1.height / 2, 1, 500); // FBOs cams cam1 = new Dw.EasyCam(fbo1._renderer, { distance: 200 }); let state1 = cam1.getState(); cam1.attachMouseListeners(this._renderer); cam1.state_reset = state1; // state to use on reset (double-click/tap) cam1.setViewport([0, 0, width / 2, height]); cam2 = new Dw.EasyCam(fbo2._renderer, { rotation: [0.94, 0.33, 0, 0] }); cam2.attachMouseListeners(this._renderer); let state2 = cam2.getState(); cam2.state_reset = state2; // state to use on reset (double-click/tap) cam2.setViewport([width / 2, 0, width / 2, height]); document.oncontextmenu = function () { return false; }; // scene colorMode(RGB, 1); let trange = 100; boxes = []; for (let i = 0; i \u0026lt; 100; i++) { boxes.push({ position: createVector( (random() * 2 - 1) * trange, (random() * 2 - 1) * trange, (random() * 2 - 1) * trange ), size: random() * 25 + 8, color: color(random(), random(), random()), }); } print(fbo1.bounds()); gui = createGui(\u0026#39;Frostum\u0026#39;); gui.addGlobals(\u0026#39;frustum_width\u0026#39;, \u0026#39;frustum_height\u0026#39;, \u0026#39;far\u0026#39;); } function draw() { fbo1.ortho(-frustum_width/2, frustum_width/2, -frustum_height/2, frustum_height/2, 1, far); fbo1.background(175, 125, 115); fbo1.reset(); fbo1.axes({ size: 100, bits: Tree.X | Tree.YNEG }); fbo1.grid(); scene(fbo1); beginHUD(); image(fbo1, 0, 0); endHUD(); fbo2.background(130); fbo2.reset(); fbo2.axes(); fbo2.grid(); scene(fbo2); fbo2.push(); fbo2.strokeWeight(3); fbo2.stroke(\u0026#39;magenta\u0026#39;); fbo2.fill(color(1, 0, 1, 0.3)); fbo2.viewFrustum({ fbo: fbo1, bits: Tree.NEAR | Tree.FAR }); fbo2.pop(); beginHUD(); image(fbo2, 0, height/ 2); endHUD(); } function scene(graphics) { boxes.forEach(box =\u0026gt; { graphics.push(); graphics.fill(box.color); graphics.translate(box.position); graphics.box(box.size); graphics.pop(); }); } Proyecci√≥n perspectiva # Esta proyecci√≥n es la m√°s similar al ojo humando. En la proyecci√≥n perspectiva, la c√°mara da una sansaci√≥n de profundidad. Entre m√°s lejano se encuentre un objeto de la c√°mara, m√°s peque√±o se ve.\ncode # sketch.js \u0026#39;use strict\u0026#39;; let fbo1, fbo2; let cam1, cam2; let height = 600; let boxes; let persp = true; var far = 500; var fovy = 100; var gui; function setup() { createCanvas(300, 600); fbo1 = createGraphics(width, height/2, WEBGL); fbo2 = createGraphics(width, height/2, WEBGL); // FBOs cams cam1 = new Dw.EasyCam(fbo1._renderer, { distance: 200 }); let state1 = cam1.getState(); cam1.attachMouseListeners(this._renderer); cam1.state_reset = state1; // state to use on reset (double-click/tap) cam1.setViewport([0, 0, width / 2, height]); cam2 = new Dw.EasyCam(fbo2._renderer, { rotation: [0.94, 0.33, 0, 0] }); cam2.attachMouseListeners(this._renderer); let state2 = cam2.getState(); cam2.state_reset = state2; // state to use on reset (double-click/tap) cam2.setViewport([width / 2, 0, width / 2, height]); document.oncontextmenu = function () { return false; }; // scene colorMode(RGB, 1); let trange = 100; boxes = []; for (let i = 0; i \u0026lt; 100; i++) { boxes.push({ position: createVector( (random() * 2 - 1) * trange, (random() * 2 - 1) * trange, (random() * 2 - 1) * trange ), size: random() * 25 + 8, color: color(random(), random(), random()), }); } print(fbo1.bounds()); gui = createGui(\u0026#39;Frostum\u0026#39;); gui.addGlobals(\u0026#39;fovy\u0026#39;, \u0026#39;far\u0026#39;); } function draw() { fbo1.perspective(fovy*(PI/3)/100, 1, 10, far); fbo1.background(175, 125, 115); fbo1.reset(); fbo1.axes({ size: 100, bits: Tree.X | Tree.YNEG }); fbo1.grid(); scene(fbo1); beginHUD(); image(fbo1, 0, 0); endHUD(); fbo2.background(130); fbo2.reset(); fbo2.axes(); fbo2.grid(); scene(fbo2); fbo2.push(); fbo2.strokeWeight(3); fbo2.stroke(\u0026#39;magenta\u0026#39;); fbo2.fill(color(1, 0, 1, 0.3)); fbo2.viewFrustum({ fbo: fbo1, bits: Tree.NEAR | Tree.FAR }); fbo2.pop(); beginHUD(); image(fbo2, 0, height/ 2); endHUD(); } function scene(graphics) { boxes.forEach(box =\u0026gt; { graphics.push(); graphics.fill(box.color); graphics.translate(box.position); graphics.box(box.size); graphics.pop(); }); } "},{"id":8,"href":"/showcase/libs/p5.treegl/README/","title":"Readme","section":"Libs","content":" p5.treegl # High-level space transformations WEBGL p5.js library which eases shader development.\nShaders Handling Macros Basic matrices Matrix queries Space transformations Heads Up Display Frustum queries Utilities Drawing stuff Installation Hacking Observe that all matrix operations in treegl are immutable, e.g., invMatrix:\nlet matrix = new p5.Matrix(); // invMatrix doesn\u0026#39;t modify its matrix param, it gives a new value let iMatrix = invMatrix(matrix); // iMatrix !== matrix Note that the functions in the shaders and basic matrices sections are available only to p5; those of the matrix queries, space transformations, Heads Up Display, utilities and drawing stuff sections are available to p5, and p5.RendererGL instances; and, those of the frustum queries section are available to p5 and p5.RendererGL, and p5.Matrix instances.\nShaders # Handling # parseVertexShader([{[precision = Tree.mediump], [matrices = Tree.pmvMatrix], [varyings = Tree.color4 | Tree.texcoords2]}]): parses precision, matrices and varyings params into a vertex shader which is returned as a string. For example: calling parseVertexShader() without any arguments will return (and also log onto the console) the following string: precision mediump float; attribute vec3 aPosition; attribute vec4 aVertexColor; attribute vec2 aTexCoord; uniform mat4 uModelViewProjectionMatrix; varying vec4 color4; varying vec2 texcoords2; void main() { color4 = aVertexColor; texcoords2 = aTexCoord; gl_Position = uModelViewProjectionMatrix * vec4(aPosition, 1.0); } readShader(fragFilename, [{[precision = Tree.mediump], [matrices = Tree.pmvMatrix], [varyings = Tree.color4 | Tree.texcoords2]}]): (similar to loadShader) loads a fragment shader from (string) file path and returns a p5.Shader. Note that the behind the scenes vertex shader is automatically generated (and log onto the console) from a call to: parseVertexShader({precision: precision, matrices: matrices, varyings: varyings}). makeShader(fragSrc, [{[precision = Tree.mediump], [matrices = Tree.pmvMatrix], [varyings = Tree.color4 | Tree.texcoords2]}]): (similar to createShader) creates a fragment shader from (string) source and returns a p5.Shader. Note that the behind the scenes vertex shader is automatically generated (and log onto the console) from a call to: parseVertexShader({precision: precision, matrices: matrices, varyings: varyings}). Observations\nThe precision param defines the vertex shader float precision. It may be either Tree.lowp, Tree.mediump or Tree.highp. The matrices param defines the vertex shader uniform matrices from Tree.pmvMatrix, Tree.pMatrix, Tree.mvMatrix, Tree.nMatrix or Tree.NONE (i.e., to not emit any matrix) bits, e.g., calling parseVertexShader({ matrices: Tree.pMatrix | Tree.mvMatrix }) would return (and also log onto the console) something like: // float precision // attributes ... uniform mat4 uProjectionMatrix; uniform mat4 uModelViewMatrix; // varyings ... void main() { // processed varyings gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0); } Matrix uniform variables are automatically emit by the p5 api, such as when issuing a camera or a translate command. Keep in mind the matrix uniform variables naming convention as defined here, since you should also follow it within your fragment shader. The varyings param defines the vertex shader attributes to be interpolated to the fragment shader from Tree.color4, Tree.texcoords2 (texture coordinates), Tree.normal3, Tree.position2, Tree.position3 or Tree.NONE (i.e., to not emit any varying) bits, e.g., calling parseVertexShader({ varyings = Tree.color4 | Tree.texcoords2 }) would return (and also log onto the console) something like: // color4 and texcoords2 names match those of // Tree.color4 and Tree.texcoords2, resp. // float precision attribute vec4 aVertexColor; attribute vec2 aTexCoord; // matrix uniforms... varying vec4 color4; varying vec2 texcoords2; void main() { color4 = aVertexColor; texcoords2 = aTexCoord; // gl_Position } which produces the default case output. Keep in mind the varying naming convention used within the vertex shader, since it should be the same you employ within your custom fragment shader. Feel free to test the parseVertexShader function described above, trying out different precision, matrices and varyings params and see what output best suit your particular needs.\nMacros # Send common uniform vec2 variables, such as: image offset, pointer position, and screen resolution, to shader. Note that the variable names are customizable.\nemitTexOffset(shader, image, [uniform = 'u_texoffset']) as: [1 / image.width, 1 / image.height]. emitMousePosition(shader, [uniform = 'u_mouse']) as: [mouseX * pixelDensity(), (height - mouseY) * pixelDensity()]. emitPointerPosition(shader, pointerX, pointerY, [uniform = 'u_pointer']) as: [pointerX * pixelDensity(), (height - pointerY) * pixelDensity()]. Available to both, the p5 object and p5.RendererGL instances. emitResolution(shader, [uniform = 'u_resolution']) as: [width * pixelDensity(), height * pixelDensity()]. Available to both, the p5 object and p5.RendererGL instances. Basic matrices # iMatrix(): Returns the identity matrix. tMatrix(matrix): Returns the tranpose of matrix. invMatrix(matrix): Returns the inverse of matrix. axbMatrix(a, b): Returns the product of the a and b matrices. Observation: All returned matrices are instances of p5.Matrix.\nMatrix queries # pMatrix(): Returns the current projection matrix. mvMatrix([{[vMatrix], [mMatrix]}]): Returns the modelview matrix. mMatrix([{[eMatrix], [mvMatrix]}]): Returns the model matrix. eMatrix(): Returns the current eye matrix (the inverse of vMatrix()). In addition to p5 and p5.RendererGL instances, this method is also available to p5.Camera objects. vMatrix(): Returns the view matrix (the inverse of eMatrix()). In addition to p5 and p5.RendererGL instances, this method is also available to p5.Camera objects. pvMatrix([{[pMatrix], [vMatrix]}]): Returns the projection times view matrix. pvInvMatrix([{[pMatrix], [vMatrix], [pvMatrix]}]): Returns the pvMatrix inverse. lMatrix([{[from = iMatrix()], [to = this.eMatrix()]}]): Returns the 4x4 matrix that transforms locations (points) from matrix from to matrix to. dMatrix([{[from = iMatrix()], [to = this.eMatrix()]}]): Returns the 3x3 matrix (only rotational part is needed) that transforms displacements (vectors) from matrix from to matrix to. The nMatrix below is a special case of this one. nMatrix([{[vMatrix], [mMatrix], [mvMatrix]}]): Returns the normal matrix. Observations\nAll returned matrices are instances of p5.Matrix. The pMatrix, vMatrix, pvMatrix, eMatrix, mMatrix and mvMatrix default values are those defined by the renderer at the moment the query is issued. Space transformations # treeLocation(vector = Tree.ORIGIN, [{[from = Tree.EYE], [to = Tree.WORLD], [pMatrix], [vMatrix], [eMatrix], [pvMatrix], [pvInvMatrix]}]): transforms locations (points) from matrix from to matrix to. treeDisplacement(vector = Tree._k, [{[from = Tree.EYE], [to = Tree.WORLD], [vMatrix], [eMatrix], [pMatrix]}]): transforms displacements (vectors) from matrix from to matrix to. Pass matrix params when you cached those matrices (see the previous section), either to speedup computations, e.g.,\nlet pvInv; functon draw() { // cache pvInv at the beginning of the rendering loop // note that this matrix rarely change within the iteration pvInv = pvInvMatrix(); // ... // speedup treeLocation treeLocation(vector, { from: Tree.WORLD, to: Tree.SCREEN, pvInvMatrix: pvInv }); treeLocation(vector, { from: Tree.WORLD, to: Tree.SCREEN, pvInvMatrix: pvInv }); // ... many more treeLocation calls.... // ... all the above treeLocation calls used the (only computed once) cached pvInv matrix } or to transform points (and vectors) between local spaces, e.g.,\nlet model; function draw() { // ... // save model matrix as it is set just before drawing your model model = mMatrix(); drawModel(); // continue drawing your tree... // let\u0026#39;s draw a bulls eye at the model origin screen projection push(); let screenProjection = treeLocation(Tree.ORIGIN, { from: model, to: Tree.SCREEN }); // which is the same as: // let screenProjection = treeLocation(createVector(0, 0, 0), { from: model, to: Tree.SCREEN }); // or, // let screenProjection = treeLocation([0, 0, 0], { from: model, to: Tree.SCREEN }); // or, more simply: // let screenProjection = treeLocation({ from: model, to: Tree.SCREEN }); bullsEye({ x: screenProjection.x, y: screenProjection.y }); pop(); } Observations\nReturned transformed vectors are instances of p5.Vector. from and to may also be specified as either: Tree.WORLD, Tree.EYE, Tree.SCREEN or Tree.NDC. When no matrix params (eMatrix, pMatrix,\u0026hellip;) are passed the renderer current values are used instead. The default treeLocation call (i.e., treeLocation(Tree.ORIGIN, {from: Tree.EYE, to: Tree.WORLD)) returns the camera world position. Note that the default treeDisplacement call (i.e., treeDisplacement(Tree._k, {from: Tree.EYE, to: Tree.WORLD)) returns the normalized camera viewing direction. Other useful vector constants, different than Tree.ORIGIN (i.e., [0, 0, 0]) and Tree._k (i.e., [0, 0, -1]), are: Tree.i (i.e., [1, 0, 0]), Tree.j (i.e., [0, 1, 0]), Tree.k (i.e., [0, 0, 1]), Tree._i (i.e., [-1, 0, 0]) and Tree._j (i.e., [0, -1, 0]). Heads Up Display # beginHUD(): Begins Heads Up Display, so that geometry specified between beginHUD() and endHUD() is defined in window space. Should always be used in conjunction with endHUD. endHUD(): Ends Heads Up Display, so that geometry specified between beginHUD() and endHUD() is defined in window space. Should always be used in conjunction with beginHUD. Frustum queries # lPlane(): Returns the left clipping plane. rPlane(): Returns the right clipping plane. bPlane(): Returns the bottom clipping plane. tPlane(): Returns the top clipping plane. nPlane(): Returns the near clipping plane. fPlane(): Returns the far clipping plane. fov(): Returns the vertical field-of-view (fov) in radians. hfov(): Returns the horizontal field-of-view (hfov) in radians. Utilities # pixelRatio(location): Returns the world to pixel ratio units at given world location, i.e., a line of n * pixelRatio(location) world units will be projected with a length of n pixels on screen. mousePicking({ [mMatrix], [x = this.width / 2], [y = this.height / 2], [size = 50], [shape = Tree.CIRCLE], [eMatrix], [pMatrix], [vMatrix], [pvMatrix] }): same as return this.pointerPicking(this.mouseX, this.mouseY, { mMatrix: mMatrix, x: x, y: y, size: size, shape: shape, eMatrix: eMatrix, pMatrix: pMatrix, vMatrix: vMatrix, pvMatrix: pvMatrix }) (see below). pointerPicking(pointerX, pointerY, { [mMatrix], [x = this.width / 2], [y = this.height / 2], [size = 50], [shape = Tree.CIRCLE], [eMatrix], [pMatrix], [vMatrix], [pvMatrix] }): Returns true if pointerX, pointerY lies within the screen space circle centered at (x, y) and having size diameter. Use mMatrix to compute (x, y) as the screen space projection of the model space origin and having size as its bounding sphere diameter. Use Tree.SQUARE to use a squared shape instead of a circled one. visibility: Returns object visibility, either as Tree.VISIBLE, Tree.INVISIBLE, or Tree.SEMIVISIBLE. Object may be either a point: visibility({ center, [bounds = this.bounds()]}), a ball: visibility({ center, radius, [bounds = this.bounds()]}) or an axis-aligned box: visibility({ corner1, corner2, [bounds = this.bounds()]}). bounds(): Returns the general form of the current frustum six plane equations, i.e., ax + by + cz + d = 0, formatted as an object literal having keys: Tree.LEFT, Tree.RIGHT, Tree.BOTTOM, Tree.TOP, Tree.NEAR and Tree.FAR, e.g., access the near plane coefficients as: let bounds = bounds(); let near = bounds[Tree.NEAR];// near.a, near.b, near.c and near.d Drawing stuff # axes([{ [size = 100], [bits = Tree.LABELS | Tree.X | Tree.Y | Tree.Z] }]): Draws axes with given size in world units, and bitwise mask that may be composed of Tree.X, Tree._X, Tree.Y, Tree._Y, Tree.Z, Tree._Z and Tree.LABELS bits. grid([{ [size = 100], [subdivisions = 10], [style = Tree.DOTS] }]): Draws grid with given size in world units, subdivisions and dotted (Tree.DOTS) or solid (Tree.SOLID) lines. cross([{ [mMatrix], [x = this.width / 2], [y = this.height / 2], [size = 50], [eMatrix], [pMatrix], [vMatrix], [pvMatrix] }]): Draws a cross at x, y screen coordinates with given size in pixels. Use mMatrix to compute (x, y) as the screen projection of the model space origin. bullsEye([{ [mMatrix], [x = this.width / 2], [y = this.height / 2], [size = 50], [shape = Tree.CIRCLE], [eMatrix], [pMatrix], [vMatrix], [pvMatrix] }]): Draws a circled bullseye (use Tree.SQUARE to draw it as a square) at x, y screen coordinates with given size in pixels. Use mMatrix to compute (x, y) as the screen projection of the model space origin. viewFrustum([{ [fbo = _renderer], [bits = Tree.NEAR | Tree.FAR], [viewer = () =\u0026gt; this.axes({ size: 50, bits: Tree.X | Tree._X | Tree.Y | Tree._Y | Tree.Z | Tree._Z })] }]): Draws frame buffer object (fbo) view frustum representation according to view-frustum bitwise mask bits which may be composed of Tree.NEAR, Tree.FAR and Tree.BODY bits, and viewer callback visual representation. Installation # Link the p5.treegl.js library into your HTML file, after you have linked in p5.js. For example:\n\u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script src=\u0026#34;p5.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;p5.sound.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;sketch.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; to include its minified version use:\n\u0026lt;script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.min.js\u0026gt;\u0026lt;/script\u0026gt; instead.\nvs-code \u0026amp; vs-codium \u0026amp; gitpod hacking instructions # To run and hack the testing examples:\nClone the repo (git clone https://github.com/VisualComputing/p5.treegl) and open it with your favorite editor. Install the p5-vscode extension. Head over examples/*/index.html and press your editor Go Live button. Don\u0026rsquo;t forget to check these p5.js references:\nLibrary creation. Software architecture. Webgl mode. Contributors ‚ú® # Thanks goes to these wonderful people (emoji key):\nJean Pierre Charalambos\nü§î üé® üì¢ üìù üí° ‚úÖ üìπ ‚ö†Ô∏è üêõ üíª dangulos\nüìñ ‚ö†Ô∏è üêõ üíª This project follows the all-contributors specification. Contributions of any kind welcome!\n"}]