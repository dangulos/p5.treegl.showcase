[{"id":0,"href":"/p5.treegl.showcase/docs/Componentes/Arrow/","title":"Arrow","section":"Componentes","content":" Arrow # A simple arrow using pipes. Useful for pointing at stuff. Can be used to show if something is moving or rotating.\nParams # Name PropType description detail number Arrow\u0026rsquo;s detail. The bigger it is, the smoother the arrow looks. radius number Arrow\u0026rsquo;s body radius. height number Arrow\u0026rsquo;s height. Showcase # Click and drag to move the camera arround!\ncode # sketch.js // gui params var detail = 16; var radius = 20; var height = 20; var gui; function setup() { createCanvas(450, 450, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); easycam.setZoomScale(false); gui = createGui(\u0026#39;Double click to close\u0026#39;); gui.addGlobals(\u0026#39;detail\u0026#39;, \u0026#39;radius\u0026#39;, \u0026#39;height\u0026#39;); } function draw() { rotateX(-0.5); rotateY(-0.5); background(255); stroke(0); strokeWeight(1); fill(0, 0, 255); push(); arrow({detail, radius, height}); pop(); } "},{"id":1,"href":"/p5.treegl.showcase/docs/Componentes/Axes/","title":"Axes","section":"Componentes","content":" Axes # Axes draws three 3D orthogonal lines which can be used as a reference point when rotating or moving an object.\nParams # Name PropType description size number Axes size, each axis has the same length bits number Bitmask that can be used to indicate which axis to show Bitmask # The bits parameter which axis to show. Even though this param is a number, it works as a Bitmask (Similar chmod\u0026rsquo;s numerical permissions in GNU/Linux). This bitmask allows different options to be chosen in a sigle parameter. p5.treegl adds the Tree object which allows easy access to all the necesary bits to mark different options. Each option is ordered as follows:\nDescription Value in Tree Binary Draws the X axis Tree.X 0000001 Draws the Y axis Tree.Y 0000010 Draws the Z axis Tree.Z 0000100 Draws the -X axis Tree._X 0001000 Draws the -Y axis Tree._Y 0010000 Draws the -Z axis Tree._Z 0100000 Draws labels that help identify each axis Tree.LABELS 1000000 Showcase # Click and drag to move the camera arround!\ncode # sketch.js var easycam; var size = 200; var LABELS = true; var bits = [\u0026#39;default\u0026#39;, \u0026#39;X Y Z\u0026#39;, \u0026#39;-X -Y -Z\u0026#39;, \u0026#39;everything\u0026#39;]; var gui; function setup() { createCanvas(400, 400, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); easycam.setZoomScale(false); gui = createGui(\u0026#39;Double click to close\u0026#39;); gui.addGlobals(\u0026#39;size\u0026#39;, \u0026#39;bits\u0026#39;); } function draw() { rotateX(-0.5); rotateY(-0.5); background(255); let selectedBits = 0; switch (bits) { case \u0026#39;X Y Z\u0026#39;: selectedBits = Tree.X | Tree.Y | Tree.Z; break; case \u0026#39;-X -Y -Z\u0026#39;: selectedBits = Tree._X | Tree._Y | Tree._Z; break; case \u0026#39;everything\u0026#39;: selectedBits = Tree.X | Tree.Y | Tree.Z | Tree.LABELS | Tree._X | Tree._Y | Tree._Z; break; default: selectedBits = Tree.X | Tree.Y | Tree.Z | Tree.LABELS; break; } push(); axes({ size: size, bits: selectedBits }); pop(); } "},{"id":2,"href":"/p5.treegl.showcase/docs/Componentes/Bagel/","title":"Bagel","section":"Componentes","content":" Bagel # Bagel or \u0026ldquo;figure 8\u0026rdquo; is an immersion of the Klein bottle. This figure can be done by joining two M√∂bius strips.\nParams # Name PropType description mayorDetail number Mayor radius detail. minorDetail number Minor radius detail. mayorRadius number Radius from the hollow center of the bagel to the center of any \u0026ldquo;pipe\u0026rdquo;. minorDetail number Radius from any \u0026ldquo;pipe\u0026rsquo;s\u0026rdquo; center to it\u0026rsquo;s external surface. Showcase # Click and drag to move the camera arround!\ncode # sketch.js // gui params var mayorRadius = 140; var minorRadius = 100; var mayorDetail = 16; var minorDetail = 16; var gui; function setup() { createCanvas(450, 450, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); easycam.setZoomScale(false); gui = createGui(\u0026#39;Double click to close\u0026#39;); gui.addGlobals(\u0026#39;mayorRadius\u0026#39;, \u0026#39;minorRadius\u0026#39;, \u0026#39;mayorDetail\u0026#39;, \u0026#39;minorDetail\u0026#39;); } function draw() { background(255); stroke(0); strokeWeight(1); fill(0, 0, 255); push(); bagel({mayorRadius, minorRadius, mayorDetail, minorDetail}); pop(); } "},{"id":3,"href":"/p5.treegl.showcase/docs/Componentes/Bullseye/","title":"Bullseye","section":"Componentes","content":" Bullseye # Bullseye is an 2D object that helps identify a 3D point\u0026rsquo;s position. Useful to identify if an object is moving.\nParams # Name PropType description x number Position in x. y number Position in y. size number Bullseye\u0026rsquo;s diameter. shape number Bullseye can be circular (using Tree.CIRCLE) or squared (using Tree.SQUARE). default is circular. Showcase # code # sketch.js // gui params var x = 300; var y = 150; var size = 100; var shape = [\u0026#39;Tree.CIRCLE\u0026#39;, \u0026#39;Tree.SQUARE\u0026#39;]; var selectedShape; var gui; function setup() { createCanvas(400, 400, WEBGL); gui = createGui(\u0026#39;Double click to close\u0026#39;); gui.addGlobals(\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;size\u0026#39;, \u0026#39;shape\u0026#39;); y = 150; noLoop(); } function draw() { // pick a shape switch (shape) { case \u0026#39;Tree.SQUARE\u0026#39;: selectedShape = Tree.SQUARE; break; default: selectedShape = Tree.CIRCLE; break; } background(255); stroke(0, 255, 255); strokeWeight(4); push(); bullsEye({ x, y, size, shape: selectedShape }); pop(); } "},{"id":4,"href":"/p5.treegl.showcase/docs/Componentes/Grid/","title":"Grid","section":"Componentes","content":" Grid # A grid is a surface with a simple squared tessellation. It can be used to mesure and object\u0026rsquo;s size, movement and rotation if placed in a relative point.\nParams # Name PropType description subdivisions number Subdivision number. size number Grid\u0026rsquo;s size. shape number The grid can be dotted (using Tree.DOTS) or solid (using Tree.SOLID). Default is dotted. Showcase # Click and drag to move the camera arround!\ncode # sketch.js // gui params var subdivisions = 10; var size = 250; var style = [\u0026#39;Tree.DOTS\u0026#39;, \u0026#39;Tree.SOLID\u0026#39;]; var selectedstyle; var gui; function setup() { createCanvas(400, 400, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); easycam.setZoomScale(false); gui = createGui(\u0026#39;Double click to close\u0026#39;); gui.addGlobals(\u0026#39;subdivisions\u0026#39;, \u0026#39;size\u0026#39;, \u0026#39;style\u0026#39;); } function draw() { // pick a style switch (style) { case \u0026#39;Tree.SOLID\u0026#39;: selectedStyle = Tree.SOLID; break; default: selectedStyle = Tree.DOTS; break; } background(255); stroke(0); strokeWeight(4); push(); grid({ subdivisions, size, style: selectedStyle }); pop(); } "},{"id":5,"href":"/p5.treegl.showcase/docs/Componentes/Mobius_Strip/","title":"Mobius Strip","section":"Componentes","content":" M√∂bius Strip # A M√∂bius Strip is a shape that only has one side.\nParams # Name PropType description detail number Strip\u0026rsquo;s detail. The bigger it is, the smoother the strip looks radius number Shape\u0026rsquo;s radius. Showcase # Click and drag to move the camera arround!\ncode # sketch.js // gui params var detail = 16; var radius = 100; var gui; function setup() { createCanvas(450, 450, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); easycam.setZoomScale(false); gui = createGui(\u0026#39;Double click to close\u0026#39;); gui.addGlobals(\u0026#39;detail\u0026#39;, \u0026#39;radius\u0026#39;); } function draw() { background(255); stroke(0); strokeWeight(1); fill(0, 0, 255); push(); mobius({detail, radius}); pop(); } "},{"id":6,"href":"/p5.treegl.showcase/docs/Componentes/Pipe/","title":"Pipe","section":"Componentes","content":" Pipe # A pipe is a cylinder whose bases can be rotated given a specified vector. This figure is useful because when several are connected, more complex figures can be made.\nParams # Name PropType description detail number Pipe\u0026rsquo;s detail. The bigger it is, the smoother the pipe looks. topRadius number Top base radius. bottomRadius number Bottom base radius. height number Pipe\u0026rsquo;s height. topNormal p5.Vector Vector indicating how the top base of the cylinder is tilted. bottomNormal p5.Vector Vector indicating how the bottom base of the cylinder is tilted. Showcase # Click and drag to move the camera arround!\ncode # sketch.js // gui params var detail = 16; var topRadius = 20; var bottomRadius = 20; var cylinderHeight = 250; var topNormal = 100; var topNormalY = 100; var bottomNormal = 100; var bottomNormalY = 100; var caps = [\u0026#39;Both\u0026#39;, \u0026#39;Tree.TOPCAP\u0026#39;, \u0026#39;Tree.BOTTOMCAP\u0026#39;]; var gui; function setup() { createCanvas(450, 450, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); easycam.setZoomScale(false); gui = createGui(\u0026#39;Double click to close\u0026#39;); gui.addGlobals(\u0026#39;detail\u0026#39;, \u0026#39;topRadius\u0026#39;, \u0026#39;bottomRadius\u0026#39;, \u0026#39;cylinderHeight\u0026#39;, \u0026#39;topNormal\u0026#39;, \u0026#39;bottomNormal\u0026#39;, \u0026#39;caps\u0026#39;); } function draw() { background(255); stroke(0); strokeWeight(1); fill(0, 0, 255); let topVector = { x: Math.sin(map(topNormal,0,100,0,TWO_PI)), y: Math.cos(map(topNormal,0,100,0,TWO_PI)), }; let bottomVector = { x: Math.sin(map(bottomNormal,0,100,0,TWO_PI)), y: Math.cos(map(bottomNormal,0,100,0,TWO_PI)), }; let selectedCaps; switch (caps) { case \u0026#39;Tree.TOPCAP\u0026#39;: selectedCaps = Tree.TOPCAP; break; case \u0026#39;Tree.BOTTOMCAP\u0026#39;: selectedCaps = Tree.BOTTOMCAP; break; default: selectedCaps = Tree.TOPCAP | Tree.BOTTOMCAP; break; } push(); translate(cylinderHeight/4,0,0) pipe({ detail, topRadius, bottomRadius, height: cylinderHeight, topNormal: new p5.Vector(topVector.x, topVector.y, 1), bottomNormal: new p5.Vector(bottomVector.x, bottomVector.y, -1), caps: selectedCaps, }); pop(); } "},{"id":7,"href":"/p5.treegl.showcase/docs/Componentes/viewFrustum/","title":"View Frustum","section":"Componentes","content":" ViewFrustum # Treegl allows you to visualize the volume that a camera is rendering through a frustum. This frustum shows the position of the screen and the camera, the render distance and the shape it has.\nParams # Name PropType description fbo p5.RendererGL or p5.Graphics The renderer to be shown by the frustum. bits number Bitmask to choose which planes to draw. viewer function Callback that allows to draw a visual representation of the fbo\u0026rsquo;s position. Bitmask # The bits parameter which planes to show. Even though this param is a number, it works as a Bitmask (Similar chmod\u0026rsquo;s numerical permissions in GNU/Linux). This bitmask allows different options to be chosen in a sigle parameter. p5.treegl adds the Tree object which allows easy access to all the necesary bits to mark different options. Each option is ordered as follows:\nDescription Value in Tree Binary Draws the far plane Tree.NEAR 0000001 Draws the near plane Tree.FAR 0000010 Draws the left boundary Tree.LEFT 0000100 Draws the right boundary Tree.RIGHT 0001000 Draws the bottom boundary Tree.BOTTOM 0010000 Draws the top boundary Tree.TOP 0100000 Draws the frustum\u0026rsquo;s body Tree.BODY 1000000 Orthographic Projection # In orthographic projection, the camera that is rendering the scene does not identify depth. This means that no matter how far away an object is from the camera, it will retain its size. It\u0026rsquo;s often used for schematics, architectural drawings, 3D software when lining up vertices and mesuring distances as they also remain constant.\nClick and drag to move the camera arround!\ncode # sketch.js \u0026#39;use strict\u0026#39;; let fbo1, fbo2; let cam1, cam2; let height = 600; let boxes; let persp = true; var left = 300; var right = 300; var frustum_width = 200; var bottom = 300; var topa = 300; var frustum_height = 200; var far = 500; var viewer = [\u0026#39;axes\u0026#39;, \u0026#39;arrow\u0026#39;]; var gui; function setup() { createCanvas(400, 700); fbo1 = createGraphics(400, 350, WEBGL); fbo2 = createGraphics(400, 350, WEBGL); fbo1.ortho(-fbo1.width / 2, fbo1.width / 2, -fbo1.height / 2, fbo1.height / 2, 1, 500); // FBOs cams cam1 = new Dw.EasyCam(fbo1._renderer, { distance: 200 }); cam1.setZoomScale(false); let state1 = cam1.getState(); cam1.attachMouseListeners(this._renderer); cam1.state_reset = state1; // state to use on reset (double-click/tap) cam1.setViewport([0, 0, width / 2, height]); cam2 = new Dw.EasyCam(fbo2._renderer, { rotation: [0.94, 0.33, 0, 0] }); cam2.setZoomScale(false); cam2.attachMouseListeners(this._renderer); let state2 = cam2.getState(); cam2.state_reset = state2; // state to use on reset (double-click/tap) cam2.setViewport([width / 2, 0, width / 2, height]); document.oncontextmenu = function () { return false; }; // scene colorMode(RGB, 1); boxes = []; for (let i = 0; i \u0026lt; 5; i++){ for (let j = 0; j \u0026lt; 5; j++) { boxes.push({ position: createVector(i * 40 - 70, 0, j * 40 - 70), size: 20, color: color(random(), random(), random()), }); } } print(fbo1.bounds()); gui = createGui(\u0026#39;Double click to close\u0026#39;).setPosition(30, 350); gui.addGlobals(\u0026#39;frustum_width\u0026#39;, \u0026#39;frustum_height\u0026#39;, \u0026#39;far\u0026#39;, \u0026#39;viewer\u0026#39;); } function draw() { fbo1.ortho(-frustum_width/2, frustum_width/2, -frustum_height/2, frustum_height/2, 1, far); fbo1.background(175, 125, 115); fbo1.reset(); fbo1.axes({ size: 100, bits: Tree.X | Tree.YNEG }); fbo1.grid(); scene(fbo1); beginHUD(); image(fbo1, 0, 0); endHUD(); fbo2.background(130); fbo2.reset(); fbo2.axes(); fbo2.grid(); scene(fbo2); fbo2.push(); fbo2.strokeWeight(3); fbo2.stroke(\u0026#39;magenta\u0026#39;); fbo2.fill(color(1, 0, 1, 0.3)); let selectedViewer; if(viewer === \u0026#39;arrow\u0026#39;){ selectedViewer = () =\u0026gt; { fbo2.push(); fbo2.stroke(\u0026#39;#0803FF\u0026#39;); fbo2.arrow({height: 50}); fbo2.pop(); }; } else { selectedViewer = () =\u0026gt; fbo2.axes({ size: 50, bits: Tree.X | Tree._X | Tree.Y | Tree._Y | Tree.Z | Tree._Z }); } fbo2.viewFrustum({ fbo: fbo1, bits: Tree.NEAR | Tree.FAR, viewer: selectedViewer }); fbo2.pop(); beginHUD(); image(fbo2, 0, 350); endHUD(); } function scene(graphics) { boxes.forEach(box =\u0026gt; { graphics.push(); graphics.fill(box.color); graphics.translate(box.position); graphics.box(box.size); graphics.pop(); }); } Perspective Projection # This projection is the most similar to the human eye. In perspective projection, the camera gives a sense of depth. The further away an object is from the camera, the smaller it appears.\nClick and drag to move the camera arround!\ncode # sketch.js \u0026#39;use strict\u0026#39;; let fbo1, fbo2; let cam1, cam2; let height = 600; let boxes; let persp = true; var far = 500; var vertical_fov = 100; var viewer = [\u0026#39;axes\u0026#39;, \u0026#39;arrow\u0026#39;]; var gui; function setup() { createCanvas(400, 700); fbo1 = createGraphics(400, 350, WEBGL); fbo2 = createGraphics(400, 350, WEBGL); // FBOs cams cam1 = new Dw.EasyCam(fbo1._renderer, { distance: 200 }); cam1.setZoomScale(false); let state1 = cam1.getState(); cam1.attachMouseListeners(this._renderer); cam1.state_reset = state1; // state to use on reset (double-click/tap) cam1.setViewport([0, 0, width / 2, height]); cam2 = new Dw.EasyCam(fbo2._renderer, { rotation: [0.94, 0.33, 0, 0] }); cam2.setZoomScale(false); cam2.attachMouseListeners(this._renderer); let state2 = cam2.getState(); cam2.state_reset = state2; // state to use on reset (double-click/tap) cam2.setViewport([width / 2, 0, width / 2, height]); document.oncontextmenu = function () { return false; }; // scene colorMode(RGB, 1); boxes = []; for (let i = 0; i \u0026lt; 5; i++){ for (let j = 0; j \u0026lt; 5; j++) { boxes.push({ position: createVector(i * 40 - 70, 0, j * 40 - 70), size: 20, color: color(random(), random(), random()), }); } } print(fbo1.bounds()); gui = createGui(\u0026#39;Double click to close\u0026#39;).setPosition(30, 350); gui.addGlobals(\u0026#39;vertical_fov\u0026#39;, \u0026#39;far\u0026#39;, \u0026#39;viewer\u0026#39;); } function draw() { fbo1.perspective(vertical_fov*(PI/3)/100, 1, 10, far); fbo1.background(175, 125, 115); fbo1.reset(); fbo1.axes({ size: 100, bits: Tree.X | Tree.YNEG }); fbo1.grid(); scene(fbo1); beginHUD(); image(fbo1, 0, 0); endHUD(); fbo2.background(130); fbo2.reset(); fbo2.axes(); fbo2.grid(); scene(fbo2); fbo2.push(); fbo2.strokeWeight(3); fbo2.stroke(\u0026#39;magenta\u0026#39;); fbo2.fill(color(1, 0, 1, 0.3)); let selectedViewer; if(viewer === \u0026#39;arrow\u0026#39;){ selectedViewer = () =\u0026gt; { fbo2.push(); fbo2.stroke(\u0026#39;#0803FF\u0026#39;); fbo2.arrow({height: 50}); fbo2.pop(); }; } else { selectedViewer = () =\u0026gt; fbo2.axes({ size: 50, bits: Tree.X | Tree._X | Tree.Y | Tree._Y | Tree.Z | Tree._Z }); } fbo2.viewFrustum({ fbo: fbo1, bits: Tree.NEAR | Tree.FAR, viewer: selectedViewer }); fbo2.pop(); beginHUD(); image(fbo2, 0, 350); endHUD(); } function scene(graphics) { boxes.forEach(box =\u0026gt; { graphics.push(); graphics.fill(box.color); graphics.translate(box.position); graphics.box(box.size); graphics.pop(); }); } "},{"id":8,"href":"/p5.treegl.showcase/libs/p5.treegl/README/","title":"Readme","section":"Libs","content":" p5.treegl # High-level space transformations WEBGL p5.js library which eases shader development.\nShaders Handling Macros Basic matrices Matrix queries Space transformations Heads Up Display Frustum queries Utilities Drawing stuff Installation Hacking Observe that all matrix operations in treegl are immutable, e.g., invMatrix:\nlet matrix = new p5.Matrix(); // invMatrix doesn\u0026#39;t modify its matrix param, it gives a new value let iMatrix = invMatrix(matrix); // iMatrix !== matrix Note that the functions in the shaders and basic matrices sections are available only to p5; those of the matrix queries, space transformations, Heads Up Display, utilities and drawing stuff sections are available to p5, and p5.RendererGL instances; and, those of the frustum queries section are available to p5 and p5.RendererGL, and p5.Matrix instances.\nShaders # Handling # parseVertexShader([{[precision = Tree.mediump], [matrices = Tree.pmvMatrix], [varyings = Tree.color4 | Tree.texcoords2]}]): parses precision, matrices and varyings params into a vertex shader which is returned as a string. For example: calling parseVertexShader() without any arguments will return (and also log onto the console) the following string: precision mediump float; attribute vec3 aPosition; attribute vec4 aVertexColor; attribute vec2 aTexCoord; uniform mat4 uModelViewProjectionMatrix; varying vec4 color4; varying vec2 texcoords2; void main() { color4 = aVertexColor; texcoords2 = aTexCoord; gl_Position = uModelViewProjectionMatrix * vec4(aPosition, 1.0); } readShader(fragFilename, [{[precision = Tree.mediump], [matrices = Tree.pmvMatrix], [varyings = Tree.color4 | Tree.texcoords2]}]): (similar to loadShader) loads a fragment shader from (string) file path and returns a p5.Shader. Note that the behind the scenes vertex shader is automatically generated (and log onto the console) from a call to: parseVertexShader({precision: precision, matrices: matrices, varyings: varyings}). makeShader(fragSrc, [{[precision = Tree.mediump], [matrices = Tree.pmvMatrix], [varyings = Tree.color4 | Tree.texcoords2]}]): (similar to createShader) creates a fragment shader from (string) source and returns a p5.Shader. Note that the behind the scenes vertex shader is automatically generated (and log onto the console) from a call to: parseVertexShader({precision: precision, matrices: matrices, varyings: varyings}). Observations\nThe precision param defines the vertex shader float precision. It may be either Tree.lowp, Tree.mediump or Tree.highp. The matrices param defines the vertex shader uniform matrices from Tree.pmvMatrix, Tree.pMatrix, Tree.mvMatrix, Tree.nMatrix or Tree.NONE (i.e., to not emit any matrix) bits, e.g., calling parseVertexShader({ matrices: Tree.pMatrix | Tree.mvMatrix }) would return (and also log onto the console) something like: // float precision // attributes ... uniform mat4 uProjectionMatrix; uniform mat4 uModelViewMatrix; // varyings ... void main() { // processed varyings gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0); } Matrix uniform variables are automatically emit by the p5 api, such as when issuing a camera or a translate command. Keep in mind the matrix uniform variables naming convention as defined here, since you should also follow it within your fragment shader. The varyings param defines the vertex shader attributes to be interpolated to the fragment shader from Tree.color4, Tree.texcoords2 (texture coordinates), Tree.normal3, Tree.position2, Tree.position3 or Tree.NONE (i.e., to not emit any varying) bits, e.g., calling parseVertexShader({ varyings = Tree.color4 | Tree.texcoords2 }) would return (and also log onto the console) something like: // color4 and texcoords2 names match those of // Tree.color4 and Tree.texcoords2, resp. // float precision attribute vec4 aVertexColor; attribute vec2 aTexCoord; // matrix uniforms... varying vec4 color4; varying vec2 texcoords2; void main() { color4 = aVertexColor; texcoords2 = aTexCoord; // gl_Position } which produces the default case output. Keep in mind the varying naming convention used within the vertex shader, since it should be the same you employ within your custom fragment shader. Feel free to test the parseVertexShader function described above, trying out different precision, matrices and varyings params and see what output best suit your particular needs.\nMacros # Send common uniform vec2 variables, such as: image offset, pointer position, and screen resolution, to shader. Note that the variable names are customizable.\nemitTexOffset(shader, image, [uniform = 'u_texoffset']) as: [1 / image.width, 1 / image.height]. emitMousePosition(shader, [uniform = 'u_mouse']) as: [mouseX * pixelDensity(), (height - mouseY) * pixelDensity()]. emitPointerPosition(shader, pointerX, pointerY, [uniform = 'u_pointer']) as: [pointerX * pixelDensity(), (height - pointerY) * pixelDensity()]. Available to both, the p5 object and p5.RendererGL instances. emitResolution(shader, [uniform = 'u_resolution']) as: [width * pixelDensity(), height * pixelDensity()]. Available to both, the p5 object and p5.RendererGL instances. Basic matrices # iMatrix(): Returns the identity matrix. tMatrix(matrix): Returns the tranpose of matrix. invMatrix(matrix): Returns the inverse of matrix. axbMatrix(a, b): Returns the product of the a and b matrices. Observation: All returned matrices are instances of p5.Matrix.\nMatrix queries # pMatrix(): Returns the current projection matrix. mvMatrix([{[vMatrix], [mMatrix]}]): Returns the modelview matrix. mMatrix([{[eMatrix], [mvMatrix]}]): Returns the model matrix. eMatrix(): Returns the current eye matrix (the inverse of vMatrix()). In addition to p5 and p5.RendererGL instances, this method is also available to p5.Camera objects. vMatrix(): Returns the view matrix (the inverse of eMatrix()). In addition to p5 and p5.RendererGL instances, this method is also available to p5.Camera objects. pvMatrix([{[pMatrix], [vMatrix]}]): Returns the projection times view matrix. pvInvMatrix([{[pMatrix], [vMatrix], [pvMatrix]}]): Returns the pvMatrix inverse. lMatrix([{[from = iMatrix()], [to = this.eMatrix()]}]): Returns the 4x4 matrix that transforms locations (points) from matrix from to matrix to. dMatrix([{[from = iMatrix()], [to = this.eMatrix()]}]): Returns the 3x3 matrix (only rotational part is needed) that transforms displacements (vectors) from matrix from to matrix to. The nMatrix below is a special case of this one. nMatrix([{[vMatrix], [mMatrix], [mvMatrix]}]): Returns the normal matrix. Observations\nAll returned matrices are instances of p5.Matrix. The pMatrix, vMatrix, pvMatrix, eMatrix, mMatrix and mvMatrix default values are those defined by the renderer at the moment the query is issued. Space transformations # treeLocation(vector = Tree.ORIGIN, [{[from = Tree.EYE], [to = Tree.WORLD], [pMatrix], [vMatrix], [eMatrix], [pvMatrix], [pvInvMatrix]}]): transforms locations (points) from matrix from to matrix to. treeDisplacement(vector = Tree._k, [{[from = Tree.EYE], [to = Tree.WORLD], [vMatrix], [eMatrix], [pMatrix]}]): transforms displacements (vectors) from matrix from to matrix to. Pass matrix params when you cached those matrices (see the previous section), either to speedup computations, e.g.,\nlet pvInv; functon draw() { // cache pvInv at the beginning of the rendering loop // note that this matrix rarely change within the iteration pvInv = pvInvMatrix(); // ... // speedup treeLocation treeLocation(vector, { from: Tree.WORLD, to: Tree.SCREEN, pvInvMatrix: pvInv }); treeLocation(vector, { from: Tree.WORLD, to: Tree.SCREEN, pvInvMatrix: pvInv }); // ... many more treeLocation calls.... // ... all the above treeLocation calls used the (only computed once) cached pvInv matrix } or to transform points (and vectors) between local spaces, e.g.,\nlet model; function draw() { // ... // save model matrix as it is set just before drawing your model model = mMatrix(); drawModel(); // continue drawing your tree... // let\u0026#39;s draw a bulls eye at the model origin screen projection push(); let screenProjection = treeLocation(Tree.ORIGIN, { from: model, to: Tree.SCREEN }); // which is the same as: // let screenProjection = treeLocation(createVector(0, 0, 0), { from: model, to: Tree.SCREEN }); // or, // let screenProjection = treeLocation([0, 0, 0], { from: model, to: Tree.SCREEN }); // or, more simply: // let screenProjection = treeLocation({ from: model, to: Tree.SCREEN }); bullsEye({ x: screenProjection.x, y: screenProjection.y }); pop(); } Observations\nReturned transformed vectors are instances of p5.Vector. from and to may also be specified as either: Tree.WORLD, Tree.EYE, Tree.SCREEN or Tree.NDC. When no matrix params (eMatrix, pMatrix,\u0026hellip;) are passed the renderer current values are used instead. The default treeLocation call (i.e., treeLocation(Tree.ORIGIN, {from: Tree.EYE, to: Tree.WORLD)) returns the camera world position. Note that the default treeDisplacement call (i.e., treeDisplacement(Tree._k, {from: Tree.EYE, to: Tree.WORLD)) returns the normalized camera viewing direction. Other useful vector constants, different than Tree.ORIGIN (i.e., [0, 0, 0]) and Tree._k (i.e., [0, 0, -1]), are: Tree.i (i.e., [1, 0, 0]), Tree.j (i.e., [0, 1, 0]), Tree.k (i.e., [0, 0, 1]), Tree._i (i.e., [-1, 0, 0]) and Tree._j (i.e., [0, -1, 0]). Heads Up Display # beginHUD(): Begins Heads Up Display, so that geometry specified between beginHUD() and endHUD() is defined in window space. Should always be used in conjunction with endHUD. endHUD(): Ends Heads Up Display, so that geometry specified between beginHUD() and endHUD() is defined in window space. Should always be used in conjunction with beginHUD. Frustum queries # lPlane(): Returns the left clipping plane. rPlane(): Returns the right clipping plane. bPlane(): Returns the bottom clipping plane. tPlane(): Returns the top clipping plane. nPlane(): Returns the near clipping plane. fPlane(): Returns the far clipping plane. fov(): Returns the vertical field-of-view (fov) in radians. hfov(): Returns the horizontal field-of-view (hfov) in radians. Utilities # pixelRatio(location): Returns the world to pixel ratio units at given world location, i.e., a line of n * pixelRatio(location) world units will be projected with a length of n pixels on screen. mousePicking({ [mMatrix], [x = this.width / 2], [y = this.height / 2], [size = 50], [shape = Tree.CIRCLE], [eMatrix], [pMatrix], [vMatrix], [pvMatrix] }): same as return this.pointerPicking(this.mouseX, this.mouseY, { mMatrix: mMatrix, x: x, y: y, size: size, shape: shape, eMatrix: eMatrix, pMatrix: pMatrix, vMatrix: vMatrix, pvMatrix: pvMatrix }) (see below). pointerPicking(pointerX, pointerY, { [mMatrix], [x = this.width / 2], [y = this.height / 2], [size = 50], [shape = Tree.CIRCLE], [eMatrix], [pMatrix], [vMatrix], [pvMatrix] }): Returns true if pointerX, pointerY lies within the screen space circle centered at (x, y) and having size diameter. Use mMatrix to compute (x, y) as the screen space projection of the model space origin and having size as its bounding sphere diameter. Use Tree.SQUARE to use a squared shape instead of a circled one. visibility: Returns object visibility, either as Tree.VISIBLE, Tree.INVISIBLE, or Tree.SEMIVISIBLE. Object may be either a point: visibility({ center, [bounds = this.bounds()]}), a ball: visibility({ center, radius, [bounds = this.bounds()]}) or an axis-aligned box: visibility({ corner1, corner2, [bounds = this.bounds()]}). bounds(): Returns the general form of the current frustum six plane equations, i.e., ax + by + cz + d = 0, formatted as an object literal having keys: Tree.LEFT, Tree.RIGHT, Tree.BOTTOM, Tree.TOP, Tree.NEAR and Tree.FAR, e.g., access the near plane coefficients as: let bounds = bounds(); let near = bounds[Tree.NEAR];// near.a, near.b, near.c and near.d Drawing stuff # axes([{ [size = 100], [bits = Tree.LABELS | Tree.X | Tree.Y | Tree.Z] }]): Draws axes with given size in world units, and bitwise mask that may be composed of Tree.X, Tree._X, Tree.Y, Tree._Y, Tree.Z, Tree._Z and Tree.LABELS bits. grid([{ [size = 100], [subdivisions = 10], [style = Tree.DOTS] }]): Draws grid with given size in world units, subdivisions and dotted (Tree.DOTS) or solid (Tree.SOLID) lines. cross([{ [mMatrix], [x = this.width / 2], [y = this.height / 2], [size = 50], [eMatrix], [pMatrix], [vMatrix], [pvMatrix] }]): Draws a cross at x, y screen coordinates with given size in pixels. Use mMatrix to compute (x, y) as the screen projection of the model space origin. bullsEye([{ [mMatrix], [x = this.width / 2], [y = this.height / 2], [size = 50], [shape = Tree.CIRCLE], [eMatrix], [pMatrix], [vMatrix], [pvMatrix] }]): Draws a circled bullseye (use Tree.SQUARE to draw it as a square) at x, y screen coordinates with given size in pixels. Use mMatrix to compute (x, y) as the screen projection of the model space origin. viewFrustum([{ [fbo = _renderer], [bits = Tree.NEAR | Tree.FAR], [viewer = () =\u0026gt; this.axes({ size: 50, bits: Tree.X | Tree._X | Tree.Y | Tree._Y | Tree.Z | Tree._Z })] }]): Draws frame buffer object (fbo) view frustum representation according to view-frustum bitwise mask bits which may be composed of Tree.NEAR, Tree.FAR and Tree.BODY bits, and viewer callback visual representation. Installation # Link the p5.treegl.js library into your HTML file, after you have linked in p5.js. For example:\n\u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script src=\u0026#34;p5.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;p5.sound.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;sketch.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; to include its minified version use:\n\u0026lt;script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.min.js\u0026gt;\u0026lt;/script\u0026gt; instead.\nvs-code \u0026amp; vs-codium \u0026amp; gitpod hacking instructions # To run and hack the testing examples:\nClone the repo (git clone https://github.com/VisualComputing/p5.treegl) and open it with your favorite editor. Install the p5-vscode extension. Head over examples/*/index.html and press your editor Go Live button. Don\u0026rsquo;t forget to check these p5.js references:\nLibrary creation. Software architecture. Webgl mode. Contributors ‚ú® # Thanks goes to these wonderful people (emoji key):\nJean Pierre Charalambos\nü§î üé® üì¢ üìù üí° ‚úÖ üìπ ‚ö†Ô∏è üêõ üíª dangulos\nüìñ ‚ö†Ô∏è üêõ üíª This project follows the all-contributors specification. Contributions of any kind welcome!\n"}]