[{"id":0,"href":"/docs/Componentes/Arrow/","title":"Arrow","section":"Componentes","content":" Arrow # Es una simple flecha hecha utilizando pipe\u0026rsquo;s. Resulta útil para señalar puntos dada la necesidad.\nParámetros # detail number : El detalle de la flecha. Entre mayor sea, más suave se ve. radius number : Radio de la flecha. height number : Altura de la flecha. Showcase # code # sketch.js // gui params var detail = 16; var radius = 20; var height = 20; var gui; function setup() { createCanvas(450, 450, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); gui = createGui(\u0026#39;Axes\u0026#39;); gui.addGlobals(\u0026#39;detail\u0026#39;, \u0026#39;radius\u0026#39;, \u0026#39;height\u0026#39;); } function draw() { rotateX(-0.5); rotateY(-0.5); background(255); stroke(0); strokeWeight(1); fill(0, 0, 255); push(); arrow({detail, radius, height}); pop(); } "},{"id":1,"href":"/docs/Componentes/Axes/","title":"Axes","section":"Componentes","content":" Axes # Los Axes (o ejes en español) dibujan tres líneas ortogonales en 3D que pueden ser útiles como punto de referencia al momento de rotar algún objeto\nParámetros # size number : Tamaño de los ejes, todos los ejes comparten la misma distancia. bits number : Bitmask que permite indicar qué ejes dibujar. Uso de la Bitmask # El parámetro bits permite elegir qué ejes se dibujan y a pesar de que el parámetro que se ingresa es un número, funciona como una Bitmask (Similar a los permisos numéricos del comando chmod en GNU/Linux). La bitmask permite que se puedan elegir distintas opciones en un sólo parámetro. La librería añade el objeto Tree que permite un acceso sencillo a los bits necesarios para marcar opciones. La distribución de las selecciones posibles se encuentra ordenada de la siguiente manera:\nDescription Valor en Tree Binario Decimal Dibuja el eje X Tree.X 0000001 1 Dibuja el eje Y Tree.Y 0000010 2 Dibuja el eje Z Tree.Z 0000100 4 Dibuja el eje -X Tree._X 0001000 8 Dibuja el eje -Y Tree._Y 0010000 16 Dibuja el eje -z Tree._Z 0100000 32 Dibuja labels que indican el eje Tree.LABELS 1000000 64 Ejemplos # Si se quisiera mostrar todos los ejes positivos sin los label se podría hacer de la siguiente manera:\naxes({ size: 100, bits: Tree.X | Tree.Y | Tree.Z }); Como sabemos que bits es un numero, puede recibir directamente un valor númerico que, aunque un poco más confuso, daría un código más corto. Simplemente se toman los valores de la tabla de arriba y se suman. Esto correspondería a 1 + 2 + 4 = 7. Por ejemplo, el siguiente código es equivalente al de arriba:\naxes({ size: 100, bits: 7 }); Showcase # code # sketch.js var easycam; var size = 100; var X = true; var Y = true; var Z = true; var _X = false; var _Y = false; var _Z = false; var LABELS = false; var gui; function setup() { createCanvas(400, 400, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); gui = createGui(\u0026#39;Axes\u0026#39;); gui.addGlobals(\u0026#39;size\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Z\u0026#39;, \u0026#39;_X\u0026#39;, \u0026#39;_Y\u0026#39;, \u0026#39;_Z\u0026#39;, \u0026#39;LABELS\u0026#39;); } function draw() { rotateX(-0.5); rotateY(-0.5); background(255); push(); axes({ size: size, bits: parseSelection() }); pop(); } function parseSelection() { let result = 0; if (X) result = result | Tree.X; if (Y) result = result | Tree.Y; if (Z) result = result | Tree.Z; if (_X) result = result | Tree._X; if (_Y) result = result | Tree._Y; if (_Z) result = result | Tree._Z; if (LABELS) result = result | Tree.LABELS; return result; } "},{"id":2,"href":"/docs/Componentes/Bagel/","title":"Bagel","section":"Componentes","content":" Bagel # El bagel o \u0026ldquo;figure 8\u0026rdquo; es una immersión de la botella de Klein. Esta figura se puede hacer uniendo dos cintas de Möbius.\nParámetros # mayorDetail number : Detalle del recorrido del radio mayor del bagel minorDetail number : Detalle del recorrido del radio menor del bagel. mayorRadius number : Radio desde el centro del bagle hasta el centro de su \u0026ldquo;cuerpo\u0026rdquo;. minorDetail number : Radio desde el centro del \u0026ldquo;cuerpo\u0026rdquo; hasta la superficie externa de este. Showcase # code # sketch.js // gui params var mayorRadius = 16; var minorRadius = 20; var mayorDetail = 16; var minorDetail = 16; var gui; function setup() { createCanvas(450, 450, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); gui = createGui(\u0026#39;Axes\u0026#39;); gui.addGlobals(\u0026#39;mayorRadius\u0026#39;, \u0026#39;minorRadius\u0026#39;, \u0026#39;mayorDetail\u0026#39;, \u0026#39;minorDetail\u0026#39;); } function draw() { rotateX(-0.5); rotateY(-0.5); background(255); stroke(0); strokeWeight(1); fill(0, 0, 255); push(); bagel({mayorRadius, minorRadius, mayorDetail, minorDetail}); pop(); } "},{"id":3,"href":"/docs/Componentes/Bullseye/","title":"Bullseye","section":"Componentes","content":" Bullseye # Los bullseye son figuras en 2D que facilitan indentificar la posición de un objeto en 3D.\nParámetros # x number : Posición en x. y number : Posición en y. size number : Diámetro del bullseye. shape number : El bullseye puede mostrarse en forma circular (con Tree.CIRCLE) o cuadrada (con Tree.SQUARE). Defacto es circular. Showcase # code # sketch.js // gui params var x = 200; var y = 200; var size = 150; var shape = [\u0026#39;Tree.CIRCLE\u0026#39;, \u0026#39;Tree.SQUARE\u0026#39;]; var selectedShape; var gui; function setup() { createCanvas(400, 400, WEBGL); gui = createGui(\u0026#39;Bullseye\u0026#39;); gui.addGlobals(\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;size\u0026#39;, \u0026#39;shape\u0026#39;); noLoop(); } function draw() { // pick a shape switch (shape) { case \u0026#39;Tree.SQUARE\u0026#39;: selectedShape = Tree.SQUARE; break; default: selectedShape = Tree.CIRCLE; break; } background(255); stroke(0, 255, 255); strokeWeight(4); push(); bullsEye({ x, y, size, shape: selectedShape }); pop(); } "},{"id":4,"href":"/docs/Componentes/Grid/","title":"Grid","section":"Componentes","content":" Grid # Una grid es una cuadrícula que facilita visualizar el tamaño, movimiento o rotación de un objeto al colocarla desde un punto relativo.\nParámetros # subdivisions number : Cantidad de subdivisiones. size number : Tamaño de la cuadrilla. shape number : La cuadrilla puede mostrarse en forma punteada (con Tree.DOTS) o sólida (con Tree.SOLID). Defacto es punteada. Showcase # code # sketch.js // gui params var subdivisions = 10; var size = 200; var style = [\u0026#39;Tree.DOTS\u0026#39;, \u0026#39;Tree.SOLID\u0026#39;]; var selectedstyle; var gui; function setup() { createCanvas(400, 400, WEBGL); gui = createGui(\u0026#39;Grid\u0026#39;); gui.addGlobals(\u0026#39;subdivisions\u0026#39;, \u0026#39;size\u0026#39;, \u0026#39;style\u0026#39;); noLoop(); } function draw() { // pick a style switch (style) { case \u0026#39;Tree.SOLID\u0026#39;: selectedStyle = Tree.SOLID; break; default: selectedStyle = Tree.DOTS; break; } background(255); stroke(0); strokeWeight(4); push(); grid({ subdivisions, size, style: selectedStyle }); pop(); } "},{"id":5,"href":"/docs/Componentes/Mobius_Strip/","title":"Mobius Strip","section":"Componentes","content":" Möbius Strip # Una cinta de Möbius es una cinta continua que tiene una sola superficie.\nParámetros # detail number : El detalle de la cinta. Entre mayor sea, más suave se ve. radius number : Radio de la cinta. Showcase # code # sketch.js // gui params var detail = 16; var radius = 20; var gui; function setup() { createCanvas(450, 450, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); gui = createGui(\u0026#39;Axes\u0026#39;); gui.addGlobals(\u0026#39;detail\u0026#39;, \u0026#39;radius\u0026#39;); } function draw() { rotateX(-0.5); rotateY(-0.5); background(255); stroke(0); strokeWeight(1); fill(0, 0, 255); push(); mobius({detail, radius}); pop(); } "},{"id":6,"href":"/docs/Componentes/Pipe/","title":"Pipe","section":"Componentes","content":" Pipe # Un pipe es un cilindro cuyas bases se pueden rotar dado un vector específico. Esta figura es útil porque cuando se concatenan varias se pueden hacer figuras más completas.\nParámetros # detail number : El detalle del cilindro. Entre mayor sea, más suave se ve. topRadius number : Radio de la base superior del cilindro. bottomRadius number : Radio de la base inferior del cilindro. height number : La altura del cilindro. topNormal p5.Vector : Vector que indica cómo está inclinada la base superior del cilindro. bottomNormal p5.Vector : Vector que indica cómo está inclinada la base inferior del cilindro. Showcase # code # sketch.js // gui params var detail = 16; var topRadius = 20; var bottomRadius = 20; var cylinderHeight = 250; var topNormalX = 100; var topNormalY = 100; var bottomNormalX = 100; var bottomNormalY = 100; var gui; function setup() { createCanvas(450, 450, WEBGL); setAttributes(\u0026#39;antialias\u0026#39;, true); easycam = createEasyCam(); gui = createGui(\u0026#39;Axes\u0026#39;); gui.addGlobals(\u0026#39;detail\u0026#39;, \u0026#39;topRadius\u0026#39;, \u0026#39;bottomRadius\u0026#39;, \u0026#39;cylinderHeight\u0026#39;, \u0026#39;topNormalX\u0026#39;, \u0026#39;topNormalY\u0026#39;, \u0026#39;bottomNormalX\u0026#39;, \u0026#39;bottomNormalY\u0026#39;); } function draw() { rotateX(-0.5); rotateY(-0.5); background(255); stroke(0); strokeWeight(1); fill(0, 0, 255); let topVector = { x: map(topNormalX, 0, 100, -1, 1), y: map(topNormalY, 0, 100, -1, 1), }; let bottomVector = { x: map(bottomNormalX, 0, 100, -1, 1), y: map(bottomNormalY, 0, 100, -1, 1), }; push(); pipe({ detail, topRadius, bottomRadius, height: cylinderHeight, topNormal: new p5.Vector(topVector.x, topVector.y, 1), bottomNormal: new p5.Vector(bottomVector.x, bottomVector.y, -1), }); pop(); } "},{"id":7,"href":"/docs/Componentes/viewFrustum/","title":"View Frustum","section":"Componentes","content":" ViewFrustum # Treegl permite visualizar el volumen que está renderizando una cámara por medio de un frustum. Éste frustum mustra la posición de la pantalla, la distancia de renderizado y la forma que esta toma.\nParámetros # fbo p5.RendererGL | p5.Graphics : Es el renderer que va a mostrar el frustum. bits number : Bitmask para controlar diversos parámetros como qué plános se dibujan. viewer function : Callback para mostrar la representación visual del fbo. Uso de la Bitmask # El parámetro bits permite elegir qué ejes se dibujan y a pesar de que el parámetro que se ingresa es un número, funciona como una Bitmask (Similar a los permisos numéricos del comando chmod en GNU/Linux). La bitmask permite que se puedan elegir distintas opciones en un sólo parámetro. La librería añade el objeto Tree que permite un acceso sencillo a los bits necesarios para marcar opciones. La distribución de las selecciones posibles se encuentra ordenada de la siguiente manera:\nDescription Valor en Tree Binario Decimal Dibuja el plano lejano Tree.NEAR 0000001 1 Dibuja el plano cercano Tree.FAR 0000010 2 Dibuja el límite izquierdo Tree.LEFT 0000100 4 Dibuja el límite derecho Tree.RIGHT 0001000 8 Dibuja el límite inferior Tree.BOTTOM 0010000 16 Dibuja el límite superior Tree.TOP 0100000 32 Dibuja el cuerpo del frostum Tree.BODY 1000000 64 Proyección ortográfica # En la proyección ortográfica, la cámara que está renderizando la escena no identifica profundidad. Esto implica que independientemente de qué tan lejos se encuentra un objeto de la cámara, éste conservará su tamaño.\ncode # sketch.js \u0026#39;use strict\u0026#39;; let fbo1, fbo2; let cam1, cam2; let height = 600; let boxes; let persp = true; var left = 300; var right = 300; var frustum_width = 600; var bottom = 300; var topa = 300; var frustum_height = 600; var far = 500; var gui; function setup() { createCanvas(300, 600); fbo1 = createGraphics(width, height/2, WEBGL); fbo2 = createGraphics(width, height/2, WEBGL); fbo1.ortho(-fbo1.width / 2, fbo1.width / 2, -fbo1.height / 2, fbo1.height / 2, 1, 500); // FBOs cams cam1 = new Dw.EasyCam(fbo1._renderer, { distance: 200 }); let state1 = cam1.getState(); cam1.attachMouseListeners(this._renderer); cam1.state_reset = state1; // state to use on reset (double-click/tap) cam1.setViewport([0, 0, width / 2, height]); cam2 = new Dw.EasyCam(fbo2._renderer, { rotation: [0.94, 0.33, 0, 0] }); cam2.attachMouseListeners(this._renderer); let state2 = cam2.getState(); cam2.state_reset = state2; // state to use on reset (double-click/tap) cam2.setViewport([width / 2, 0, width / 2, height]); document.oncontextmenu = function () { return false; }; // scene colorMode(RGB, 1); let trange = 100; boxes = []; for (let i = 0; i \u0026lt; 100; i++) { boxes.push({ position: createVector( (random() * 2 - 1) * trange, (random() * 2 - 1) * trange, (random() * 2 - 1) * trange ), size: random() * 25 + 8, color: color(random(), random(), random()), }); } print(fbo1.bounds()); gui = createGui(\u0026#39;Frostum\u0026#39;); gui.addGlobals(\u0026#39;frustum_width\u0026#39;, \u0026#39;frustum_height\u0026#39;, \u0026#39;far\u0026#39;); } function draw() { fbo1.ortho(-frustum_width/2, frustum_width/2, -frustum_height/2, frustum_height/2, 1, far); fbo1.background(175, 125, 115); fbo1.reset(); fbo1.axes({ size: 100, bits: Tree.X | Tree.YNEG }); fbo1.grid(); scene(fbo1); beginHUD(); image(fbo1, 0, 0); endHUD(); fbo2.background(130); fbo2.reset(); fbo2.axes(); fbo2.grid(); scene(fbo2); fbo2.push(); fbo2.strokeWeight(3); fbo2.stroke(\u0026#39;magenta\u0026#39;); fbo2.fill(color(1, 0, 1, 0.3)); fbo2.viewFrustum({ fbo: fbo1, bits: Tree.NEAR | Tree.FAR }); fbo2.pop(); beginHUD(); image(fbo2, 0, height/ 2); endHUD(); } function scene(graphics) { boxes.forEach(box =\u0026gt; { graphics.push(); graphics.fill(box.color); graphics.translate(box.position); graphics.box(box.size); graphics.pop(); }); } Proyección perspectiva # Esta proyección es la más similar al ojo humando. En la proyección perspectiva, la cámara da una sansación de profundidad. Entre más lejano se encuentre un objeto de la cámara, más pequeño se ve.\ncode # sketch.js \u0026#39;use strict\u0026#39;; let fbo1, fbo2; let cam1, cam2; let height = 600; let boxes; let persp = true; var far = 500; var fovy = 100; var gui; function setup() { createCanvas(300, 600); fbo1 = createGraphics(width, height/2, WEBGL); fbo2 = createGraphics(width, height/2, WEBGL); // FBOs cams cam1 = new Dw.EasyCam(fbo1._renderer, { distance: 200 }); let state1 = cam1.getState(); cam1.attachMouseListeners(this._renderer); cam1.state_reset = state1; // state to use on reset (double-click/tap) cam1.setViewport([0, 0, width / 2, height]); cam2 = new Dw.EasyCam(fbo2._renderer, { rotation: [0.94, 0.33, 0, 0] }); cam2.attachMouseListeners(this._renderer); let state2 = cam2.getState(); cam2.state_reset = state2; // state to use on reset (double-click/tap) cam2.setViewport([width / 2, 0, width / 2, height]); document.oncontextmenu = function () { return false; }; // scene colorMode(RGB, 1); let trange = 100; boxes = []; for (let i = 0; i \u0026lt; 100; i++) { boxes.push({ position: createVector( (random() * 2 - 1) * trange, (random() * 2 - 1) * trange, (random() * 2 - 1) * trange ), size: random() * 25 + 8, color: color(random(), random(), random()), }); } print(fbo1.bounds()); gui = createGui(\u0026#39;Frostum\u0026#39;); gui.addGlobals(\u0026#39;fovy\u0026#39;, \u0026#39;far\u0026#39;); } function draw() { fbo1.perspective(fovy*(PI/3)/100, 1, 10, far); fbo1.background(175, 125, 115); fbo1.reset(); fbo1.axes({ size: 100, bits: Tree.X | Tree.YNEG }); fbo1.grid(); scene(fbo1); beginHUD(); image(fbo1, 0, 0); endHUD(); fbo2.background(130); fbo2.reset(); fbo2.axes(); fbo2.grid(); scene(fbo2); fbo2.push(); fbo2.strokeWeight(3); fbo2.stroke(\u0026#39;magenta\u0026#39;); fbo2.fill(color(1, 0, 1, 0.3)); fbo2.viewFrustum({ fbo: fbo1, bits: Tree.NEAR | Tree.FAR }); fbo2.pop(); beginHUD(); image(fbo2, 0, height/ 2); endHUD(); } function scene(graphics) { boxes.forEach(box =\u0026gt; { graphics.push(); graphics.fill(box.color); graphics.translate(box.position); graphics.box(box.size); graphics.pop(); }); } "},{"id":8,"href":"/libs/p5.treegl/README/","title":"Readme","section":"Libs","content":" p5.treegl # High-level space transformations WEBGL p5.js library which eases shader development.\nShaders Handling Macros Basic matrices Matrix queries Space transformations Heads Up Display Frustum queries Utilities Drawing stuff Installation Hacking Observe that all matrix operations in treegl are immutable, e.g., invMatrix:\nlet matrix = new p5.Matrix(); // invMatrix doesn\u0026#39;t modify its matrix param, it gives a new value let iMatrix = invMatrix(matrix); // iMatrix !== matrix Note that the functions in the shaders and basic matrices sections are available only to p5; those of the matrix queries, space transformations, Heads Up Display, utilities and drawing stuff sections are available to p5, and p5.RendererGL instances; and, those of the frustum queries section are available to p5 and p5.RendererGL, and p5.Matrix instances.\nShaders # Handling # parseVertexShader([{[precision = Tree.mediump], [matrices = Tree.pmvMatrix], [varyings = Tree.color4 | Tree.texcoords2]}]): parses precision, matrices and varyings params into a vertex shader which is returned as a string. For example: calling parseVertexShader() without any arguments will return (and also log onto the console) the following string: precision mediump float; attribute vec3 aPosition; attribute vec4 aVertexColor; attribute vec2 aTexCoord; uniform mat4 uModelViewProjectionMatrix; varying vec4 color4; varying vec2 texcoords2; void main() { color4 = aVertexColor; texcoords2 = aTexCoord; gl_Position = uModelViewProjectionMatrix * vec4(aPosition, 1.0); } readShader(fragFilename, [{[precision = Tree.mediump], [matrices = Tree.pmvMatrix], [varyings = Tree.color4 | Tree.texcoords2]}]): (similar to loadShader) loads a fragment shader from (string) file path and returns a p5.Shader. Note that the behind the scenes vertex shader is automatically generated (and log onto the console) from a call to: parseVertexShader({precision: precision, matrices: matrices, varyings: varyings}). makeShader(fragSrc, [{[precision = Tree.mediump], [matrices = Tree.pmvMatrix], [varyings = Tree.color4 | Tree.texcoords2]}]): (similar to createShader) creates a fragment shader from (string) source and returns a p5.Shader. Note that the behind the scenes vertex shader is automatically generated (and log onto the console) from a call to: parseVertexShader({precision: precision, matrices: matrices, varyings: varyings}). Observations\nThe precision param defines the vertex shader float precision. It may be either Tree.lowp, Tree.mediump or Tree.highp. The matrices param defines the vertex shader uniform matrices from Tree.pmvMatrix, Tree.pMatrix, Tree.mvMatrix, Tree.nMatrix or Tree.NONE (i.e., to not emit any matrix) bits, e.g., calling parseVertexShader({ matrices: Tree.pMatrix | Tree.mvMatrix }) would return (and also log onto the console) something like: // float precision // attributes ... uniform mat4 uProjectionMatrix; uniform mat4 uModelViewMatrix; // varyings ... void main() { // processed varyings gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0); } Matrix uniform variables are automatically emit by the p5 api, such as when issuing a camera or a translate command. Keep in mind the matrix uniform variables naming convention as defined here, since you should also follow it within your fragment shader. The varyings param defines the vertex shader attributes to be interpolated to the fragment shader from Tree.color4, Tree.texcoords2 (texture coordinates), Tree.normal3, Tree.position2, Tree.position3 or Tree.NONE (i.e., to not emit any varying) bits, e.g., calling parseVertexShader({ varyings = Tree.color4 | Tree.texcoords2 }) would return (and also log onto the console) something like: // color4 and texcoords2 names match those of // Tree.color4 and Tree.texcoords2, resp. // float precision attribute vec4 aVertexColor; attribute vec2 aTexCoord; // matrix uniforms... varying vec4 color4; varying vec2 texcoords2; void main() { color4 = aVertexColor; texcoords2 = aTexCoord; // gl_Position } which produces the default case output. Keep in mind the varying naming convention used within the vertex shader, since it should be the same you employ within your custom fragment shader. Feel free to test the parseVertexShader function described above, trying out different precision, matrices and varyings params and see what output best suit your particular needs.\nMacros # Send common uniform vec2 variables, such as: image offset, pointer position, and screen resolution, to shader. Note that the variable names are customizable.\nemitTexOffset(shader, image, [uniform = 'u_texoffset']) as: [1 / image.width, 1 / image.height]. emitMousePosition(shader, [uniform = 'u_mouse']) as: [mouseX * pixelDensity(), (height - mouseY) * pixelDensity()]. emitPointerPosition(shader, pointerX, pointerY, [uniform = 'u_pointer']) as: [pointerX * pixelDensity(), (height - pointerY) * pixelDensity()]. Available to both, the p5 object and p5.RendererGL instances. emitResolution(shader, [uniform = 'u_resolution']) as: [width * pixelDensity(), height * pixelDensity()]. Available to both, the p5 object and p5.RendererGL instances. Basic matrices # iMatrix(): Returns the identity matrix. tMatrix(matrix): Returns the tranpose of matrix. invMatrix(matrix): Returns the inverse of matrix. axbMatrix(a, b): Returns the product of the a and b matrices. Observation: All returned matrices are instances of p5.Matrix.\nMatrix queries # pMatrix(): Returns the current projection matrix. mvMatrix([{[vMatrix], [mMatrix]}]): Returns the modelview matrix. mMatrix([{[eMatrix], [mvMatrix]}]): Returns the model matrix. eMatrix(): Returns the current eye matrix (the inverse of vMatrix()). In addition to p5 and p5.RendererGL instances, this method is also available to p5.Camera objects. vMatrix(): Returns the view matrix (the inverse of eMatrix()). In addition to p5 and p5.RendererGL instances, this method is also available to p5.Camera objects. pvMatrix([{[pMatrix], [vMatrix]}]): Returns the projection times view matrix. pvInvMatrix([{[pMatrix], [vMatrix], [pvMatrix]}]): Returns the pvMatrix inverse. lMatrix([{[from = iMatrix()], [to = this.eMatrix()]}]): Returns the 4x4 matrix that transforms locations (points) from matrix from to matrix to. dMatrix([{[from = iMatrix()], [to = this.eMatrix()]}]): Returns the 3x3 matrix (only rotational part is needed) that transforms displacements (vectors) from matrix from to matrix to. The nMatrix below is a special case of this one. nMatrix([{[vMatrix], [mMatrix], [mvMatrix]}]): Returns the normal matrix. Observations\nAll returned matrices are instances of p5.Matrix. The pMatrix, vMatrix, pvMatrix, eMatrix, mMatrix and mvMatrix default values are those defined by the renderer at the moment the query is issued. Space transformations # treeLocation(vector = Tree.ORIGIN, [{[from = Tree.EYE], [to = Tree.WORLD], [pMatrix], [vMatrix], [eMatrix], [pvMatrix], [pvInvMatrix]}]): transforms locations (points) from matrix from to matrix to. treeDisplacement(vector = Tree._k, [{[from = Tree.EYE], [to = Tree.WORLD], [vMatrix], [eMatrix], [pMatrix]}]): transforms displacements (vectors) from matrix from to matrix to. Pass matrix params when you cached those matrices (see the previous section), either to speedup computations, e.g.,\nlet pvInv; functon draw() { // cache pvInv at the beginning of the rendering loop // note that this matrix rarely change within the iteration pvInv = pvInvMatrix(); // ... // speedup treeLocation treeLocation(vector, { from: Tree.WORLD, to: Tree.SCREEN, pvInvMatrix: pvInv }); treeLocation(vector, { from: Tree.WORLD, to: Tree.SCREEN, pvInvMatrix: pvInv }); // ... many more treeLocation calls.... // ... all the above treeLocation calls used the (only computed once) cached pvInv matrix } or to transform points (and vectors) between local spaces, e.g.,\nlet model; function draw() { // ... // save model matrix as it is set just before drawing your model model = mMatrix(); drawModel(); // continue drawing your tree... // let\u0026#39;s draw a bulls eye at the model origin screen projection push(); let screenProjection = treeLocation(Tree.ORIGIN, { from: model, to: Tree.SCREEN }); // which is the same as: // let screenProjection = treeLocation(createVector(0, 0, 0), { from: model, to: Tree.SCREEN }); // or, // let screenProjection = treeLocation([0, 0, 0], { from: model, to: Tree.SCREEN }); // or, more simply: // let screenProjection = treeLocation({ from: model, to: Tree.SCREEN }); bullsEye({ x: screenProjection.x, y: screenProjection.y }); pop(); } Observations\nReturned transformed vectors are instances of p5.Vector. from and to may also be specified as either: Tree.WORLD, Tree.EYE, Tree.SCREEN or Tree.NDC. When no matrix params (eMatrix, pMatrix,\u0026hellip;) are passed the renderer current values are used instead. The default treeLocation call (i.e., treeLocation(Tree.ORIGIN, {from: Tree.EYE, to: Tree.WORLD)) returns the camera world position. Note that the default treeDisplacement call (i.e., treeDisplacement(Tree._k, {from: Tree.EYE, to: Tree.WORLD)) returns the normalized camera viewing direction. Other useful vector constants, different than Tree.ORIGIN (i.e., [0, 0, 0]) and Tree._k (i.e., [0, 0, -1]), are: Tree.i (i.e., [1, 0, 0]), Tree.j (i.e., [0, 1, 0]), Tree.k (i.e., [0, 0, 1]), Tree._i (i.e., [-1, 0, 0]) and Tree._j (i.e., [0, -1, 0]). Heads Up Display # beginHUD(): Begins Heads Up Display, so that geometry specified between beginHUD() and endHUD() is defined in window space. Should always be used in conjunction with endHUD. endHUD(): Ends Heads Up Display, so that geometry specified between beginHUD() and endHUD() is defined in window space. Should always be used in conjunction with beginHUD. Frustum queries # lPlane(): Returns the left clipping plane. rPlane(): Returns the right clipping plane. bPlane(): Returns the bottom clipping plane. tPlane(): Returns the top clipping plane. nPlane(): Returns the near clipping plane. fPlane(): Returns the far clipping plane. fov(): Returns the vertical field-of-view (fov) in radians. hfov(): Returns the horizontal field-of-view (hfov) in radians. Utilities # pixelRatio(location): Returns the world to pixel ratio units at given world location, i.e., a line of n * pixelRatio(location) world units will be projected with a length of n pixels on screen. mousePicking({ [mMatrix], [x = this.width / 2], [y = this.height / 2], [size = 50], [shape = Tree.CIRCLE], [eMatrix], [pMatrix], [vMatrix], [pvMatrix] }): same as return this.pointerPicking(this.mouseX, this.mouseY, { mMatrix: mMatrix, x: x, y: y, size: size, shape: shape, eMatrix: eMatrix, pMatrix: pMatrix, vMatrix: vMatrix, pvMatrix: pvMatrix }) (see below). pointerPicking(pointerX, pointerY, { [mMatrix], [x = this.width / 2], [y = this.height / 2], [size = 50], [shape = Tree.CIRCLE], [eMatrix], [pMatrix], [vMatrix], [pvMatrix] }): Returns true if pointerX, pointerY lies within the screen space circle centered at (x, y) and having size diameter. Use mMatrix to compute (x, y) as the screen space projection of the model space origin and having size as its bounding sphere diameter. Use Tree.SQUARE to use a squared shape instead of a circled one. visibility: Returns object visibility, either as Tree.VISIBLE, Tree.INVISIBLE, or Tree.SEMIVISIBLE. Object may be either a point: visibility({ center, [bounds = this.bounds()]}), a ball: visibility({ center, radius, [bounds = this.bounds()]}) or an axis-aligned box: visibility({ corner1, corner2, [bounds = this.bounds()]}). bounds(): Returns the general form of the current frustum six plane equations, i.e., ax + by + cz + d = 0, formatted as an object literal having keys: Tree.LEFT, Tree.RIGHT, Tree.BOTTOM, Tree.TOP, Tree.NEAR and Tree.FAR, e.g., access the near plane coefficients as: let bounds = bounds(); let near = bounds[Tree.NEAR];// near.a, near.b, near.c and near.d Drawing stuff # axes([{ [size = 100], [bits = Tree.LABELS | Tree.X | Tree.Y | Tree.Z] }]): Draws axes with given size in world units, and bitwise mask that may be composed of Tree.X, Tree._X, Tree.Y, Tree._Y, Tree.Z, Tree._Z and Tree.LABELS bits. grid([{ [size = 100], [subdivisions = 10], [style = Tree.DOTS] }]): Draws grid with given size in world units, subdivisions and dotted (Tree.DOTS) or solid (Tree.SOLID) lines. cross([{ [mMatrix], [x = this.width / 2], [y = this.height / 2], [size = 50], [eMatrix], [pMatrix], [vMatrix], [pvMatrix] }]): Draws a cross at x, y screen coordinates with given size in pixels. Use mMatrix to compute (x, y) as the screen projection of the model space origin. bullsEye([{ [mMatrix], [x = this.width / 2], [y = this.height / 2], [size = 50], [shape = Tree.CIRCLE], [eMatrix], [pMatrix], [vMatrix], [pvMatrix] }]): Draws a circled bullseye (use Tree.SQUARE to draw it as a square) at x, y screen coordinates with given size in pixels. Use mMatrix to compute (x, y) as the screen projection of the model space origin. viewFrustum([{ [fbo = _renderer], [bits = Tree.NEAR | Tree.FAR], [viewer = () =\u0026gt; this.axes({ size: 50, bits: Tree.X | Tree._X | Tree.Y | Tree._Y | Tree.Z | Tree._Z })] }]): Draws frame buffer object (fbo) view frustum representation according to view-frustum bitwise mask bits which may be composed of Tree.NEAR, Tree.FAR and Tree.BODY bits, and viewer callback visual representation. Installation # Link the p5.treegl.js library into your HTML file, after you have linked in p5.js. For example:\n\u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script src=\u0026#34;p5.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;p5.sound.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;sketch.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; to include its minified version use:\n\u0026lt;script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.min.js\u0026gt;\u0026lt;/script\u0026gt; instead.\nvs-code \u0026amp; vs-codium \u0026amp; gitpod hacking instructions # To run and hack the testing examples:\nClone the repo (git clone https://github.com/VisualComputing/p5.treegl) and open it with your favorite editor. Install the p5-vscode extension. Head over examples/*/index.html and press your editor Go Live button. Don\u0026rsquo;t forget to check these p5.js references:\nLibrary creation. Software architecture. Webgl mode. Contributors ✨ # Thanks goes to these wonderful people (emoji key):\nJean Pierre Charalambos\n🤔 🎨 📢 📝 💡 ✅ 📹 ⚠️ 🐛 💻 dangulos\n📖 ⚠️ 🐛 💻 This project follows the all-contributors specification. Contributions of any kind welcome!\n"}]